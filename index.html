<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Live ISS Tracker - 3D</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0a0a0a">
    
    <style>
        html, body { margin: 0; padding: 0; overflow: hidden; height: 100%; background-color: #0a0a0a; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; color: #fff; }
        .video-container { position: relative; width: 100vw; height: 50vh; background-color: #000; }
        #player { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; object-fit: cover; }
        .map-container { position: relative; width: 100vw; height: 50vh; cursor: grab; touch-action: none; }
        #globe-container { width: 100%; height: 100%; }
        .info-panel { position: absolute; top: 0; left: 0; width: 100%; z-index: 1000; background: rgba(0, 0, 0, 0.8); padding: 8px 0; box-sizing: border-box; border-bottom: 1px solid rgba(255, 255, 255, 0.2); display: flex; justify-content: space-around; align-items: center; text-align: center; font-size: 12px; }
        .info-item { flex: 1; }
        .info-item .label { display: block; font-size: 10px; color: #aaa; text-transform: uppercase; }
        .info-item .value { font-size: 14px; font-weight: bold; color: #4dc3ff; }
        .location-btn { position: absolute; bottom: 10px; left: 10px; z-index: 1000; background-color: rgba(0, 0, 0, 0.75); color: #fff; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; padding: 8px 12px; font-size: 14px; cursor: pointer; }
        @keyframes pulse { 0% { transform: scale(1); filter: drop-shadow(0 0 2px #fff); } 50% { transform: scale(1.1); filter: drop-shadow(0 0 8px #00bfff); } 100% { transform: scale(1); filter: drop-shadow(0 0 2px #fff); } }
        .iss-icon-wrapper { animation: pulse 3s infinite ease-in-out; }
        .iss-icon-wrapper svg { width: 48px; height: 48px; fill: #e0e0e0; }
    </style>
</head>
<body>
    <div class="video-container"><div id="player"></div></div>
    <div class="map-container" id="map-container">
        <div id="globe-container"></div>
        <button class="location-btn" id="track-me-btn">Track Me</button>
        <div class="info-panel">
            <div class="info-item"><span class="label">Speed</span><span class="value" id="speed">...</span> km/h</div>
            <div class="info-item"><span class="label">Altitude</span><span class="value" id="altitude">...</span> km</div>
            <div class="info-item"><span class="label">Location</span><span class="value" id="location">...</span></div>
            </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
        // --- PWA & YouTube Setup ---
        if ('serviceWorker' in navigator) { window.addEventListener('load', () => { navigator.serviceWorker.register('./service-worker.js').then(reg => console.log('SW registered.')).catch(err => console.error('SW reg failed:', err)); }); }
        let player;
        function onYouTubeIframeAPIReady() { player = new YT.Player('player', { videoId: 'yf5cEJULZXk', playerVars: { 'playsinline': 1, 'controls': 0, 'autoplay': 1, 'mute': 1, 'rel': 0 }, events: { 'onReady': (event) => { event.target.playVideo(); } } }); }

        // --- Three.js 3D Globe Setup ---
        const container = document.getElementById('globe-container');
        let scene, camera, renderer, earth, clouds, iss, userMarker;
        let trajectoryTube, lastIssPosition = new THREE.Vector3(), targetIssPosition = new THREE.Vector3();
        let animationStartTime = 0;
        const animationDuration = 5000;
        const EARTH_RADIUS = 100;
        const ISS_ALTITUDE_SCALE = 5;
        let trajectoryPoints = [];
        let isUserLocationSet = false;

        let radius = 250;
        const minRadius = 105; 
        const maxRadius = 500;
        const ISS_ICON_BASE_SCALE_X = 15;
        const ISS_ICON_BASE_SCALE_Y = 10;

        function initGlobe() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // --- CORRECTED: Lights now use your specified settings ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.19);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0x999999, 2.92);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);

            const textureLoader = new THREE.TextureLoader();
            const starGeometry = new THREE.SphereGeometry(900, 64, 64);
            const starMaterial = new THREE.MeshBasicMaterial({ map: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/starry-night-sky.jpg'), side: THREE.BackSide });
            scene.add(new THREE.Mesh(starGeometry, starMaterial));
            
            // --- CORRECTED: Earth material now uses your specified settings ---
            const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 64, 64);
            const earthMaterial = new THREE.MeshPhongMaterial({
                map: textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/2_no_clouds_4k.jpg'),
                specularMap: textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/water_4k.png'),
                color: new THREE.Color(0x5c5c5c),        // Earth Tint
                specular: new THREE.Color(0x00007f),     // Ocean Color
                shininess: 0                             // Ocean Shine
            });
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            scene.add(earth);

            const cloudGeometry = new THREE.SphereGeometry(EARTH_RADIUS + 0.5, 64, 64);
            const cloudMaterial = new THREE.MeshPhongMaterial({ map: textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/fair_clouds_4k.png'), transparent: true, opacity: 0.4 });
            clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
            scene.add(clouds);

            const issSVG = `<svg viewBox="0 0 100 66" xmlns="http://www.w3.org/2000/svg"><g fill="#e0e0e0"><path d="M72.5,25.5 L72.5,10.5 L60.5,10.5 L60.5,25.5 L72.5,25.5 Z M39.5,25.5 L39.5,10.5 L27.5,10.5 L27.5,25.5 L39.5,25.5 Z"/><path d="M72.5,55.5 L72.5,40.5 L60.5,40.5 L60.5,55.5 L72.5,55.5 Z M39.5,55.5 L39.5,40.5 L27.5,40.5 L27.5,55.5 L39.5,55.5 Z"/><rect x="0.5" y="28.5" width="99" height="9"/><rect x="42.5" y="18.5" width="15" height="29"/></g></svg>`;
            const issTexture = new THREE.TextureLoader().load(`data:image/svg+xml;charset=utf-8,${encodeURIComponent(issSVG)}`);
            const issSpriteMaterial = new THREE.SpriteMaterial({ map: issTexture });
            iss = new THREE.Sprite(issSpriteMaterial);
            scene.add(iss);
            
            const tubeMaterial = new THREE.MeshBasicMaterial({ color: 0xFF6600 });
            trajectoryTube = new THREE.Mesh(new THREE.BufferGeometry(), tubeMaterial);
            scene.add(trajectoryTube);
            
            userMarker = new THREE.Mesh(new THREE.SphereGeometry(1.5, 8, 8), new THREE.MeshBasicMaterial({ color: 0x4dc3ff }));
            userMarker.visible = false;
            scene.add(userMarker);
            
            addCameraControls();
            animate();
        }

        function latLonToVector3(lat, lon, radius) { const phi = (90 - lat) * (Math.PI / 180); const theta = (lon + 180) * (Math.PI / 180); return new THREE.Vector3( -radius * Math.sin(phi) * Math.cos(theta), radius * Math.cos(phi), radius * Math.sin(phi) * Math.sin(theta) ); }

        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const elapsed = now - animationStartTime;
            const progress = Math.min(elapsed / animationDuration, 1);
            if (lastIssPosition.length() > 0 && targetIssPosition.length() > 0) {
                 iss.position.lerpVectors(lastIssPosition, targetIssPosition, progress);
            }
            const zoomRatio = (radius - minRadius) / (maxRadius - minRadius);
            const scaleFactor = 0.6 + zoomRatio * 0.9;
            iss.scale.set(ISS_ICON_BASE_SCALE_X * scaleFactor, ISS_ICON_BASE_SCALE_Y * scaleFactor, 1);
            camera.position.copy(iss.position).normalize().multiplyScalar(radius);
            camera.lookAt(earth.position);
            if (isUserLocationSet) {
                const angleToCamera = camera.position.angleTo(userMarker.position);
                userMarker.visible = angleToCamera < Math.PI / 2;
            }
            renderer.render(scene, camera);
        }
        
        function addCameraControls() {
            const mapContainer = document.getElementById('map-container');
            let initialPinchDistance = 0;
            mapContainer.addEventListener('wheel', e => { e.preventDefault(); radius += e.deltaY * 0.1; radius = Math.max(minRadius, Math.min(maxRadius, radius)); });
            mapContainer.addEventListener('touchstart', e => { if (e.touches.length === 2) { initialPinchDistance = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY); } });
            mapContainer.addEventListener('touchmove', e => { if (e.touches.length === 2) { e.preventDefault(); const currentPinchDistance = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY); const delta = currentPinchDistance - initialPinchDistance; radius -= delta * 0.5; radius = Math.max(minRadius, Math.min(maxRadius, radius)); initialPinchDistance = currentPinchDistance; } });
        }

        const SATELLITE_ID = 25544;
        
        function updateTrajectoryTube() { if (trajectoryPoints.length < 2) return; const curve = new THREE.CatmullRomCurve3(trajectoryPoints); const tubeGeometry = new THREE.TubeGeometry(curve, 64, 0.4, 8, false); trajectoryTube.geometry.dispose(); trajectoryTube.geometry = tubeGeometry; }
        async function fetchInitialTrajectory() { try { const now = Math.floor(Date.now() / 1000); let timestamps = []; for (let i = 0; i <= 20; i++) timestamps.push(now - (i * 60)); const response = await fetch(`https://api.wheretheiss.at/v1/satellites/${SATELLITE_ID}/positions?timestamps=${timestamps.join(',')}`); const data = await response.json(); trajectoryPoints = data.map(pos => latLonToVector3(pos.latitude, pos.longitude, EARTH_RADIUS + ISS_ALTITUDE_SCALE)).reverse(); updateTrajectoryTube(); } catch (error) { console.error("Error fetching initial trajectory:", error); } }
        async function updateISSData() { try { const response = await fetch(`https://api.wheretheiss.at/v1/satellites/${SATELLITE_ID}`); const data = await response.json(); lastIssPosition.copy(iss.position); targetIssPosition.copy(latLonToVector3(data.latitude, data.longitude, EARTH_RADIUS + ISS_ALTITUDE_SCALE)); animationStartTime = performance.now(); if (trajectoryPoints.length > 60) trajectoryPoints.shift(); trajectoryPoints.push(targetIssPosition.clone()); updateTrajectoryTube(); document.getElementById('speed').textContent = data.velocity.toFixed(0); document.getElementById('altitude').textContent = data.altitude.toFixed(0); updateLocationName(data.latitude, data.longitude); } catch (error) { console.error("Error fetching ISS data:", error); } }
        async function updateLocationName(lat, lon) { try { const geo_api_url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=3`; const response = await fetch(geo_api_url); const data = await response.json(); let locationName = "Over an Ocean"; if (data.address) { locationName = data.address.country || data.address.water || locationName; } document.getElementById('location').textContent = locationName; } catch (error) { document.getElementById('location').textContent = "N/A"; } }
        
        const trackMeBtn = document.getElementById('track-me-btn');
        trackMeBtn.addEventListener('click', () => { trackMeBtn.textContent = "Locating..."; navigator.geolocation.getCurrentPosition(locationSuccess, locationError); });
        function locationError() { trackMeBtn.textContent = "Location Denied"; }
        function locationSuccess(position) {
            const { latitude, longitude } = position.coords;
            userMarker.position.copy(latLonToVector3(latitude, longitude, EARTH_RADIUS + 0.1));
            isUserLocationSet = true;
            trackMeBtn.textContent = "Track Me";
        }

        async function initialize() { initGlobe(); await fetchInitialTrajectory(); await updateISSData(); lastIssPosition.copy(targetIssPosition); iss.position.copy(targetIssPosition); setInterval(updateISSData, 5000); }
        initialize();
        window.addEventListener('resize', () => { camera.aspect = container.clientWidth / container.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(container.clientWidth, container.clientHeight); });
    </script>
</body>
</html>
