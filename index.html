<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Live ISS Tracker</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0a0a0a">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    
    <style>
        /* ... existing styles ... */
        html, body { margin: 0; padding: 0; overflow: hidden; height: 100%; background-color: #0a0a0a; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; color: #fff; }
        .video-container { position: relative; width: 100vw; height: 50vh; background-color: #000; }
        #player { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; object-fit: cover; }
        .map-container { position: relative; width: 100vw; height: 50vh; }
        #map { width: 100%; height: 100%; background-color: #1a1a1a; }
        .info-panel { position: absolute; bottom: 0; left: 0; width: 100%; z-index: 1000; background: rgba(0, 0, 0, 0.8); padding: 8px 0; box-sizing: border-box; border-top: 1px solid rgba(255, 255, 255, 0.2); display: flex; justify-content: space-around; align-items: center; text-align: center; font-size: 12px; }
        .info-item { flex: 1; }
        .info-item .label { display: block; font-size: 10px; color: #aaa; text-transform: uppercase; }
        .info-item .value { font-size: 14px; font-weight: bold; color: #4dc3ff; }
        @keyframes pulse { 0% { transform: scale(1); filter: drop-shadow(0 0 2px #fff); } 50% { transform: scale(1.1); filter: drop-shadow(0 0 8px #00bfff); } 100% { transform: scale(1); filter: drop-shadow(0 0 2px #fff); } }
        .iss-icon-wrapper { animation: pulse 3s infinite ease-in-out; }
        .iss-icon-wrapper svg { width: 48px; height: 48px; fill: #e0e0e0; }
        /* NEW: Style for the location button */
        .location-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.75);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="video-container"><div id="player"></div></div>
    <div class="map-container">
        <div id="map"></div>
        <button class="location-btn" id="track-me-btn">Track Me</button>
        <div class="info-panel">
            <div class="info-item"><span class="label">Speed</span><span class="value" id="speed">...</span> km/h</div>
            <div class="info-item"><span class="label">Altitude</span><span class="value" id="altitude">...</span> km</div>
            <div class="info-item"><span class="label">Location</span><span class="value" id="location">...</span></div>
            <div class="info-item"><span class="label">Next Pass</span><span class="value" id="next-pass">...</span></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
        // --- NEW: PWA Service Worker Registration ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(reg => console.log('Service Worker registered.', reg))
                    .catch(err => console.error('Service Worker registration failed:', err));
            });
        }

        // --- YouTube Player Setup (Unchanged) ---
        let player;
        function onYouTubeIframeAPIReady() { /* ... existing code ... */ }
        function onYouTubeIframeAPIReady() { player = new YT.Player('player', { videoId: 'yf5cEJULZXk', playerVars: { 'playsinline': 1, 'controls': 0, 'autoplay': 1, 'mute': 1, 'rel': 0 }, events: { 'onReady': (event) => { event.target.playVideo(); } } }); }
        
        // --- Leaflet Map & ISS Tracker Setup (Unchanged) ---
        const map = L.map('map', { zoomControl: false, attributionControl: false }).setView([0, 0], 3);
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { maxZoom: 19 }).addTo(map);
        const issSVG = `<div class="iss-icon-wrapper"><svg viewBox="0 0 100 66" xmlns="http://www.w3.org/2000/svg"><g><path d="M72.5,25.5 L72.5,10.5 L60.5,10.5 L60.5,25.5 L72.5,25.5 Z M39.5,25.5 L39.5,10.5 L27.5,10.5 L27.5,25.5 L39.5,25.5 Z"/><path d="M72.5,55.5 L72.5,40.5 L60.5,40.5 L60.5,55.5 L72.5,55.5 Z M39.5,55.5 L39.5,40.5 L27.5,40.5 L27.5,55.5 L39.5,55.5 Z"/><rect x="0.5" y="28.5" width="99" height="9"/><rect x="42.5" y="18.5" width="15" height="29"/></g></svg></div>`;
        const issIcon = L.divIcon({ html: issSVG, className: '', iconSize: [48, 48], iconAnchor: [24, 24] });
        const issMarker = L.marker([0, 0], { icon: issIcon }).addTo(map);
        let trajectoryCoords = [];
        const trajectoryLine = L.polyline([], { color: '#00bfff', weight: 2, opacity: 0.8 }).addTo(map);
        const SATELLITE_ID = 25544;
        let lastPosition = null, nextPosition = null, animationStartTime = 0;
        const animationDuration = 5000;
        function animateMarker() { /* ... existing code ... */ }
        async function fetchInitialTrajectory() { /* ... existing code ... */ }
        async function updateISSData() { /* ... existing code ... */ }
        async function updateLocationName(lat, lon) { /* ... existing code ... */ }
        async function initialize() { /* ... existing code ... */ }
        
        // Re-pasting existing functions for completeness
        function animateMarker() { const now = performance.now(); const elapsed = now - animationStartTime; const progress = Math.min(elapsed / animationDuration, 1); if (lastPosition && nextPosition) { const lat = lastPosition.lat + (nextPosition.lat - lastPosition.lat) * progress; const lng = lastPosition.lng + (nextPosition.lng - lastPosition.lng) * progress; const newLatLng = [lat, lng]; issMarker.setLatLng(newLatLng); map.panTo(newLatLng, { animate: false }); } if (progress < 1) { requestAnimationFrame(animateMarker); } }
        async function fetchInitialTrajectory() { try { const now = Math.floor(Date.now() / 1000); let timestamps = []; for (let i = 0; i <= 20; i++) { timestamps.push(now - (i * 60)); } const response = await fetch(`https://api.wheretheiss.at/v1/satellites/${SATELLITE_ID}/positions?timestamps=${timestamps.join(',')}`); const data = await response.json(); trajectoryCoords = data.map(pos => [pos.latitude, pos.longitude]).reverse(); trajectoryLine.setLatLngs(trajectoryCoords); } catch (error) { console.error("Error fetching initial trajectory:", error); } }
        async function updateISSData() { try { const response = await fetch(`https://api.wheretheiss.at/v1/satellites/${SATELLITE_ID}`); const data = await response.json(); lastPosition = issMarker.getLatLng(); nextPosition = L.latLng(data.latitude, data.longitude); animationStartTime = performance.now(); requestAnimationFrame(animateMarker); trajectoryCoords.push([data.latitude, data.longitude]); if (trajectoryCoords.length > 500) { trajectoryCoords.shift(); } trajectoryLine.addLatLng([data.latitude, data.longitude]); document.getElementById('speed').textContent = data.velocity.toFixed(0); document.getElementById('altitude').textContent = data.altitude.toFixed(0); updateLocationName(data.latitude, data.longitude); } catch (error) { console.error("Error fetching ISS data:", error); } }
        async function updateLocationName(lat, lon) { try { const geo_api_url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=3`; const response = await fetch(geo_api_url); const data = await response.json(); let locationName = "Over an Ocean"; if (data.address) { locationName = data.address.country || data.address.water || locationName; } document.getElementById('location').textContent = locationName; } catch (error) { document.getElementById('location').textContent = "N/A"; } }
        async function initialize() { await fetchInitialTrajectory(); await updateISSData(); lastPosition = issMarker.getLatLng(); setInterval(updateISSData, 5000); }
        initialize();


        // --- NEW: Next Pass and Notification Logic ---
        const trackMeBtn = document.getElementById('track-me-btn');
        const nextPassEl = document.getElementById('next-pass');

        trackMeBtn.addEventListener('click', () => {
            nextPassEl.textContent = "Locating...";
            navigator.geolocation.getCurrentPosition(locationSuccess, locationError);
        });

        function locationError() {
            nextPassEl.textContent = "Location denied";
        }

        async function locationSuccess(position) {
            const { latitude, longitude } = position.coords;
            L.circle([latitude, longitude], { radius: 10000, color: '#4dc3ff', opacity: 0.5 }).addTo(map); // Add a circle for user's location
            
            try {
                // Using Open Notify API for pass predictions
                const response = await fetch(`https://api.open-notify.org/iss-pass.json?lat=${latitude}&lon=${longitude}&n=1`);
                const data = await response.json();

                if (data.message === 'success' && data.response.length > 0) {
                    const pass = data.response[0];
                    const risetime = pass.risetime * 1000; // Convert to milliseconds
                    
                    schedulePass(risetime);
                } else {
                    nextPassEl.textContent = "No pass soon";
                }
            } catch (error) {
                console.error("Error fetching pass data:", error);
                nextPassEl.textContent = "API Error";
            }
        }

        function schedulePass(risetime) {
            const now = Date.now();
            const timeToPass = risetime - now;
            
            // Update the info panel with a countdown
            const hours = Math.floor(timeToPass / (1000 * 60 * 60));
            const minutes = Math.floor((timeToPass % (1000 * 60 * 60)) / (1000 * 60));
            nextPassEl.textContent = `in ${hours}h ${minutes}m`;

            // Ask for permission and schedule the notification
            Notification.requestPermission().then(permission => {
                if (permission === 'granted' && navigator.serviceWorker.controller) {
                    // Send the pass time to the service worker to schedule the notification
                    const fiveMinutesBefore = risetime - (5 * 60 * 1000);
                    navigator.serviceWorker.controller.postMessage({
                        type: 'SCHEDULE_NOTIFICATION',
                        risetime: fiveMinutesBefore
                    });
                    console.log('Notification scheduled by Service Worker.');
                }
            });
        }
    </script>
</body>
</html>
